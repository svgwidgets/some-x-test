/**
 * Base I/O Component
 * 
 * Foundation for all P&ID components with data binding.
 * Represents a single I/O point (analog or digital) that can receive
 * real-time data from PLCs, SCADA systems, or other data sources.
 */

export interface IOMetadata {
  /** Last update timestamp (Unix ms) */
  timestamp?: number;
  
  /** Data quality indicator */
  quality?: 'good' | 'bad' | 'uncertain';
  
  /** Source of the data (e.g., "PLC1", "Modbus", "OPC-UA") */
  source?: string;
  
  /** Additional metadata */
  [key: string]: any;
}

export interface IOComponent<T = any> {
  /** Unique identifier for this I/O point */
  id: string;
  
  /** Data channel/tag path (e.g., "plc1.valves.V001.state") */
  channel: string;
  
  /** Current value of the I/O point */
  value: T;
  
  /** Type discriminator for runtime type checking */
  ioType: 'digital' | 'analog';
  
  /** Optional metadata about the data */
  metadata?: IOMetadata;
  
  /** Human-readable description */
  description?: string;
}

/**
 * Base class for I/O components (can be extended)
 */
export abstract class BaseIOComponent<T = any> implements IOComponent<T> {
  id: string;
  channel: string;
  value: T;
  ioType: 'digital' | 'analog';
  metadata?: IOMetadata;
  description?: string;
  
  constructor(config: {
    id: string;
    channel: string;
    value: T;
    ioType: 'digital' | 'analog';
    description?: string;
  }) {
    this.id = config.id;
    this.channel = config.channel;
    this.value = config.value;
    this.ioType = config.ioType;
    this.description = config.description;
    this.metadata = {
      timestamp: Date.now(),
      quality: 'good',
    };
  }
  
  /**
   * Update the I/O value with new data
   */
  updateValue(newValue: T, metadata?: Partial<IOMetadata>): void {
    this.value = newValue;
    this.metadata = {
      ...this.metadata,
      ...metadata,
      timestamp: Date.now(),
    };
  }
  
  /**
   * Check if data is fresh (updated within threshold)
   */
  isFresh(thresholdMs: number = 5000): boolean {
    if (!this.metadata?.timestamp) return false;
    return (Date.now() - this.metadata.timestamp) < thresholdMs;
  }
  
  /**
   * Check if data quality is good
   */
  hasGoodQuality(): boolean {
    return this.metadata?.quality === 'good';
  }
}
