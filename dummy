<template>
  <g
    :transform="`translate(${position.x}, ${position.y}) rotate(${rotation}, ${centerX}, ${centerY})`"
    :class="['svg-component', `svg-${visual.id}`, { 'svg-selected': selected }]"
  >
    <!-- Render SVG content -->
    <g v-html="renderedSVG" :class="colorClasses"></g>
    
    <!-- Ports (optional) -->
    <g v-if="showPorts" class="ports">
      <circle
        v-for="port in visual.ports"
        :key="port.id"
        :cx="port.position.x"
        :cy="port.position.y"
        :r="portRadius"
        :class="['port', `port-${port.type}`]"
        :fill="portColor(port.type)"
        stroke="#333"
        stroke-width="1.5"
      />
    </g>
    
    <!-- Label -->
    <text
      v-if="label"
      :x="centerX"
      :y="-8"
      text-anchor="middle"
      font-size="10"
      font-weight="bold"
      fill="#333"
      class="component-label"
    >
      {{ label }}
    </text>
  </g>
</template>

<script setup lang="ts">
import { computed } from 'vue';
import type { VisualDefinition, Position } from './VisualDefinition';

interface Props {
  visual: VisualDefinition;
  position: Position;
  rotation?: number;
  color?: string | Record<string, string>;
  label?: string;
  showPorts?: boolean;
  selected?: boolean;
  portRadius?: number;
}

const props = withDefaults(defineProps<Props>(), {
  rotation: 0,
  showPorts: false,
  selected: false,
  portRadius: 4,
});

// Center point for rotation
const centerX = computed(() => props.visual.viewBox.width / 2);
const centerY = computed(() => props.visual.viewBox.height / 2);

// Rendered SVG (wrap in <g> if it's just paths)
const renderedSVG = computed(() => {
  const svg = props.visual.svg;
  
  // If SVG contains full elements (like <circle>, <path>), use as is
  if (svg.includes('<')) {
    return svg;
  }
  
  // If it's just path data, wrap in path element
  return `<path d="${svg}" class="svg-shape" />`;
});

// Color classes for CSS targeting
const colorClasses = computed(() => {
  if (typeof props.color === 'string') {
    return 'single-color';
  }
  return 'multi-color';
});

// Port color based on type
function portColor(type: string): string {
  const colors: Record<string, string> = {
    inlet: '#2196F3',
    outlet: '#FF9800',
    bidirectional: '#4CAF50',
  };
  return colors[type] || '#FFC107';
}
</script>

<style scoped>
.svg-component {
  cursor: default;
  transition: filter var(--transition-fast);
}

.svg-component:hover {
  filter: brightness(1.05);
}

.svg-selected {
  filter: drop-shadow(0 0 8px rgba(33, 150, 243, 0.6));
}

/* Single color mode */
.single-color .svg-shape,
.single-color path {
  fill: v-bind('typeof color === "string" ? color : "currentColor"');
  stroke: #333;
  stroke-width: 2;
}

/* Multi-color mode - handled via deep CSS */
.multi-color >>> .valve-body {
  fill: v-bind('typeof color === "object" ? color[".valve-body"] : "currentColor"');
  stroke: #333;
  stroke-width: 2;
}

.multi-color >>> .valve-actuator {
  fill: v-bind('typeof color === "object" ? color[".valve-actuator"] : "currentColor"');
  stroke: #333;
  stroke-width: 2;
}

.multi-color >>> .pump-casing {
  stroke: #333;
  stroke-width: 2;
  fill: none;
}

.multi-color >>> .pump-impeller {
  fill: v-bind('typeof color === "object" ? color[".pump-impeller"] : "currentColor"');
}

.multi-color >>> .tank-outline {
  stroke: #333;
  stroke-width: 2;
  fill: none;
}

.multi-color >>> .tank-liquid {
  fill: v-bind('typeof color === "object" ? color[".tank-liquid"] : "#2196F3"');
  opacity: 0.8;
}

.multi-color >>> .sensor-box {
  fill: white;
  stroke: #333;
  stroke-width: 2;
}

.multi-color >>> .sensor-value {
  fill: v-bind('typeof color === "object" ? color[".sensor-value"] : "#1976D2"');
}

.port {
  cursor: crosshair;
  transition: all var(--transition-fast);
}

.port:hover {
  r: 6;
  filter: brightness(1.3) drop-shadow(0 0 4px currentColor);
}

.component-label {
  pointer-events: none;
  user-select: none;
}
</style>
