/**
 * Animation Controller
 * 
 * Manages and applies animations to components based on I/O state.
 */

import type { IOComponent } from '../io/IOComponent';
import type { AnimationDefinition, AnimationState } from './AnimationDefinition';
import { isDigitalIO, isAnalogIO } from '../io';

/**
 * Animation Controller class
 */
export class AnimationController {
  private activeAnimations: Map<string, AnimationState>;
  private animationFrameId: number | null;
  
  constructor() {
    this.activeAnimations = new Map();
    this.animationFrameId = null;
  }
  
  /**
   * Check if animation should be active
   */
  shouldAnimate(animation: AnimationDefinition, io: IOComponent): boolean {
    try {
      return animation.condition(io);
    } catch (error) {
      console.error(`[AnimationController] Condition error for ${animation.id}:`, error);
      return false;
    }
  }
  
  /**
   * Calculate animation value
   */
  calculateValue(animation: AnimationDefinition, io: IOComponent): any {
    if (!animation.valueCalculator) return null;
    
    try {
      return animation.valueCalculator(io);
    } catch (error) {
      console.error(`[AnimationController] Value calculation error for ${animation.id}:`, error);
      return null;
    }
  }
  
  /**
   * Apply animation to element
   */
  applyAnimation(
    element: SVGElement | HTMLElement,
    animation: AnimationDefinition,
    io: IOComponent
  ): void {
    const shouldAnimate = this.shouldAnimate(animation, io);
    const stateKey = `${io.id}-${animation.id}`;
    
    if (!shouldAnimate) {
      // Stop animation
      this.stopAnimation(element, animation);
      this.activeAnimations.delete(stateKey);
      return;
    }
    
    // Start or update animation
    const calculatedValue = this.calculateValue(animation, io);
    
    switch (animation.type) {
      case 'rotation':
        this.applyRotation(element, animation, calculatedValue);
        break;
      
      case 'fill':
        this.applyFill(element, animation, calculatedValue);
        break;
      
      case 'flow':
        this.applyFlow(element, animation, io);
        break;
      
      case 'scale':
        this.applyScale(element, animation, calculatedValue);
        break;
      
      case 'opacity':
        this.applyOpacity(element, animation, calculatedValue);
        break;
      
      case 'stroke-dash':
        this.applyStrokeDash(element, animation);
        break;
    }
    
    // Track animation state
    this.activeAnimations.set(stateKey, {
      animationId: animation.id,
      componentId: io.id,
      isActive: true,
      startTime: Date.now(),
      currentValue: calculatedValue,
    });
  }
  
  /**
   * Apply rotation animation
   */
  private applyRotation(
    element: SVGElement | HTMLElement,
    animation: AnimationDefinition,
    value?: number
  ): void {
    const config = animation.config;
    const duration = config.duration || 2000;
    
    // CSS animation
    element.style.animation = `rotate ${duration}ms linear infinite`;
    
    // If value provided, set rotation directly
    if (value !== undefined && value !== null) {
      element.style.transform = `rotate(${value}deg)`;
    }
  }
  
  /**
   * Apply fill animation
   */
  private applyFill(
    element: SVGElement | HTMLElement,
    animation: AnimationDefinition,
    percentage?: number
  ): void {
    if (percentage === undefined || percentage === null) return;
    
    const config = animation.config;
    const duration = config.duration || 500;
    
    // For SVG rect (tank liquid)
    if (element instanceof SVGRectElement) {
      const container = config.container || { x: 0, y: 15, width: 44, height: 90 };
      const height = (percentage / 100) * container.height;
      const y = container.y + container.height - height;
      
      element.style.transition = `y ${duration}ms ${config.easing || 'ease-out'}, height ${duration}ms ${config.easing || 'ease-out'}`;
      element.setAttribute('y', y.toString());
      element.setAttribute('height', height.toString());
    }
  }
  
  /**
   * Apply flow animation
   */
  private applyFlow(
    element: SVGElement | HTMLElement,
    animation: AnimationDefinition,
    io: IOComponent
  ): void {
    const config = animation.config;
    const duration = config.duration || 2000;
    
    // Apply CSS animation to flow dots
    element.style.animation = `flow ${duration}ms linear infinite`;
  }
  
  /**
   * Apply scale animation
   */
  private applyScale(
    element: SVGElement | HTMLElement,
    animation: AnimationDefinition,
    value?: number
  ): void {
    const config = animation.config;
    const duration = config.duration || 300;
    const scale = value || 1;
    
    element.style.transition = `transform ${duration}ms ${config.easing || 'ease-out'}`;
    element.style.transform = `scale(${scale})`;
  }
  
  /**
   * Apply opacity animation
   */
  private applyOpacity(
    element: SVGElement | HTMLElement,
    animation: AnimationDefinition,
    value?: number
  ): void {
    const config = animation.config;
    const duration = config.duration || 1000;
    
    if (config.repeat) {
      // Blinking effect
      element.style.animation = `blink ${duration}ms linear infinite ${config.direction || 'alternate'}`;
    } else if (value !== undefined) {
      // Direct opacity
      element.style.transition = `opacity ${duration}ms ${config.easing || 'ease'}`;
      element.style.opacity = value.toString();
    }
  }
  
  /**
   * Apply stroke-dash animation
   */
  private applyStrokeDash(
    element: SVGElement | HTMLElement,
    animation: AnimationDefinition
  ): void {
    const config = animation.config;
    const duration = config.duration || 1000;
    
    if (element instanceof SVGElement) {
      element.style.animation = `dash ${duration}ms linear infinite`;
    }
  }
  
  /**
   * Stop animation
   */
  private stopAnimation(
    element: SVGElement | HTMLElement,
    animation: AnimationDefinition
  ): void {
    element.style.animation = '';
    
    switch (animation.type) {
      case 'rotation':
        element.style.transform = '';
        break;
      case 'opacity':
        element.style.opacity = '1';
        break;
    }
  }
  
  /**
   * Get active animation count
   */
  get activeCount(): number {
    return this.activeAnimations.size;
  }
  
  /**
   * Clear all animations
   */
  clearAll(): void {
    this.activeAnimations.clear();
    if (this.animationFrameId !== null) {
      cancelAnimationFrame(this.animationFrameId);
      this.animationFrameId = null;
    }
  }
}

// Singleton instance
export const animationController = new AnimationController();
