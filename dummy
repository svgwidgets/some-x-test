/**
 * Animation Library
 * 
 * Predefined animation definitions for common P&ID components.
 */

import type { AnimationDefinition } from './AnimationDefinition';
import { ANIMATION_CONDITIONS, VALUE_CALCULATORS } from './AnimationDefinition';

/**
 * Pump rotation animation
 */
export const PUMP_ROTATION: AnimationDefinition = {
  id: 'pump-rotation',
  type: 'rotation',
  target: '.pump-impeller',
  condition: ANIMATION_CONDITIONS.digitalTrue,
  config: {
    duration: 2000,
    easing: 'linear',
    repeat: true,
    direction: 'normal',
  },
  description: 'Rotates pump impeller when running',
};

/**
 * Motor rotation animation
 */
export const MOTOR_ROTATION: AnimationDefinition = {
  id: 'motor-rotation',
  type: 'rotation',
  target: '.motor-rotor',
  condition: ANIMATION_CONDITIONS.digitalTrue,
  config: {
    duration: 1500,
    easing: 'linear',
    repeat: true,
  },
  description: 'Rotates motor when on',
};

/**
 * Tank fill animation
 */
export const TANK_FILL: AnimationDefinition = {
  id: 'tank-fill',
  type: 'fill',
  target: '.tank-liquid',
  condition: ANIMATION_CONDITIONS.always,
  config: {
    duration: 500,
    easing: 'ease-out',
    direction: 'bottom-to-top',
  },
  valueCalculator: VALUE_CALCULATORS.analogPercentage,
  description: 'Animates tank liquid level based on analog value',
};

/**
 * Pipe flow animation
 */
export const PIPE_FLOW: AnimationDefinition = {
  id: 'pipe-flow',
  type: 'flow',
  target: '.flow-dot',
  condition: ANIMATION_CONDITIONS.analogPositive,
  config: {
    duration: 2000,
    easing: 'linear',
    repeat: true,
    dotCount: 4,
    dotSize: 3,
  },
  description: 'Animates flow dots when flow is positive',
};

/**
 * Valve opening animation
 */
export const VALVE_TRANSITION: AnimationDefinition = {
  id: 'valve-transition',
  type: 'opacity',
  target: '.valve-body',
  condition: (io) => isDigitalIO(io) && io.transitioning,
  config: {
    duration: 500,
    easing: 'ease-in-out',
    repeat: 3,
    direction: 'alternate',
  },
  description: 'Pulses valve during transition',
};

/**
 * Alarm blink animation
 */
export const ALARM_BLINK: AnimationDefinition = {
  id: 'alarm-blink',
  type: 'opacity',
  target: '.alarm-indicator',
  condition: (io) => {
    if (isAnalogIO(io)) {
      return io.isInAlarm();
    }
    return false;
  },
  config: {
    duration: 1000,
    easing: 'linear',
    repeat: true,
    direction: 'alternate',
  },
  description: 'Blinks alarm indicator',
};

/**
 * Gauge needle rotation
 */
export const GAUGE_NEEDLE: AnimationDefinition = {
  id: 'gauge-needle',
  type: 'rotation',
  target: '.gauge-needle',
  condition: ANIMATION_CONDITIONS.always,
  config: {
    duration: 300,
    easing: 'ease-out',
  },
  valueCalculator: (io) => {
    // Map 0-100% to -90 to +90 degrees
    return VALUE_CALCULATORS.mapRange(0, 100, -90, 90)(io);
  },
  description: 'Rotates gauge needle based on value',
};

/**
 * All predefined animations
 */
export const PREDEFINED_ANIMATIONS: AnimationDefinition[] = [
  PUMP_ROTATION,
  MOTOR_ROTATION,
  TANK_FILL,
  PIPE_FLOW,
  VALVE_TRANSITION,
  ALARM_BLINK,
  GAUGE_NEEDLE,
];

/**
 * Animation library class
 */
export class AnimationLibrary {
  private animations: Map<string, AnimationDefinition>;
  
  constructor() {
    this.animations = new Map();
    this.loadPredefinedAnimations();
  }
  
  /**
   * Load predefined animations
   */
  private loadPredefinedAnimations(): void {
    PREDEFINED_ANIMATIONS.forEach(animation => {
      this.register(animation);
    });
  }
  
  /**
   * Register an animation
   */
  register(animation: AnimationDefinition): void {
    if (this.animations.has(animation.id)) {
      console.warn(`[AnimationLibrary] Overwriting animation: ${animation.id}`);
    }
    this.animations.set(animation.id, animation);
  }
  
  /**
   * Get animation by ID
   */
  get(id: string): AnimationDefinition | undefined {
    return this.animations.get(id);
  }
  
  /**
   * Check if animation exists
   */
  has(id: string): boolean {
    return this.animations.has(id);
  }
  
  /**
   * Get all animations
   */
  getAll(): AnimationDefinition[] {
    return Array.from(this.animations.values());
  }
  
  /**
   * Get animations by type
   */
  getByType(type: string): AnimationDefinition[] {
    return this.getAll().filter(anim => anim.type === type);
  }
  
  /**
   * Remove animation
   */
  unregister(id: string): boolean {
    return this.animations.delete(id);
  }
  
  /**
   * Clear all animations
   */
  clear(): void {
    this.animations.clear();
  }
  
  /**
   * Get count
   */
  get count(): number {
    return this.animations.size;
  }
}

// Singleton instance
export const animationLibrary = new AnimationLibrary();

// Import helper for type checking
import { isDigitalIO, isAnalogIO } from '../io';
