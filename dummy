/**
 * Animation Definition System
 * 
 * Generic animation abstraction for P&ID components.
 * Supports rotation, fill, flow, scale, and custom animations.
 */

import type { IOComponent } from '../io/IOComponent';
import { isDigitalIO, isAnalogIO } from '../io';

/**
 * Animation types
 */
export type AnimationType = 
  | 'rotation'      // Continuous rotation (pumps, motors)
  | 'fill'          // Fill level animation (tanks)
  | 'flow'          // Flow dots animation (pipes)
  | 'scale'         // Scale animation (pulsing)
  | 'opacity'       // Fade in/out
  | 'stroke-dash'   // Dashed stroke animation
  | 'custom';       // Custom animation

/**
 * Animation easing functions
 */
export type AnimationEasing = 
  | 'linear'
  | 'ease'
  | 'ease-in'
  | 'ease-out'
  | 'ease-in-out'
  | 'cubic-bezier';

/**
 * Animation condition function
 */
export type AnimationCondition = (io: IOComponent) => boolean;

/**
 * Animation value calculator
 */
export type AnimationValueCalculator = (io: IOComponent) => number | string;

/**
 * Base animation configuration
 */
export interface BaseAnimationConfig {
  /** Animation duration in milliseconds */
  duration?: number;
  
  /** Easing function */
  easing?: AnimationEasing;
  
  /** Repeat animation */
  repeat?: boolean | number;
  
  /** Delay before starting */
  delay?: number;
  
  /** Animation direction (normal, reverse, alternate) */
  direction?: 'normal' | 'reverse' | 'alternate' | 'alternate-reverse';
}

/**
 * Rotation animation config
 */
export interface RotationAnimationConfig extends BaseAnimationConfig {
  /** Rotation speed (RPM or degrees/second) */
  speed?: number;
  
  /** Transform origin (default: center) */
  origin?: { x: number; y: number };
  
  /** Clockwise or counter-clockwise */
  clockwise?: boolean;
}

/**
 * Fill animation config
 */
export interface FillAnimationConfig extends BaseAnimationConfig {
  /** Fill direction (bottom-to-top, top-to-bottom, etc.) */
  direction?: 'bottom-to-top' | 'top-to-bottom' | 'left-to-right' | 'right-to-left';
  
  /** Container dimensions */
  container?: {
    x: number;
    y: number;
    width: number;
    height: number;
  };
}

/**
 * Flow animation config
 */
export interface FlowAnimationConfig extends BaseAnimationConfig {
  /** Number of flow dots */
  dotCount?: number;
  
  /** Dot size */
  dotSize?: number;
  
  /** Dot spacing */
  spacing?: number;
  
  /** Flow speed (pixels per second) */
  speed?: number;
}

/**
 * Scale animation config
 */
export interface ScaleAnimationConfig extends BaseAnimationConfig {
  /** Scale range (from, to) */
  scale?: { from: number; to: number };
  
  /** Transform origin */
  origin?: { x: number; y: number };
}

/**
 * Main animation definition
 */
export interface AnimationDefinition {
  /** Unique animation ID */
  id: string;
  
  /** Animation type */
  type: AnimationType;
  
  /** Target element selector (CSS selector or element ID) */
  target: string;
  
  /** Condition for when animation should be active */
  condition: AnimationCondition;
  
  /** Animation configuration */
  config: BaseAnimationConfig;
  
  /** Optional: Calculate dynamic values (e.g., RPM from I/O) */
  valueCalculator?: AnimationValueCalculator;
  
  /** Optional: Description */
  description?: string;
}

/**
 * Animation state (for tracking)
 */
export interface AnimationState {
  animationId: string;
  componentId: string;
  isActive: boolean;
  startTime?: number;
  currentValue?: any;
}

/**
 * Common animation conditions
 */
export const ANIMATION_CONDITIONS = {
  /** Animation active when digital I/O is true */
  digitalTrue: (io: IOComponent): boolean => {
    return isDigitalIO(io) && io.value === true;
  },
  
  /** Animation active when digital I/O is false */
  digitalFalse: (io: IOComponent): boolean => {
    return isDigitalIO(io) && io.value === false;
  },
  
  /** Animation active when analog I/O value > 0 */
  analogPositive: (io: IOComponent): boolean => {
    return isAnalogIO(io) && io.value > 0;
  },
  
  /** Animation active when analog I/O value > threshold */
  analogAboveThreshold: (threshold: number) => (io: IOComponent): boolean => {
    return isAnalogIO(io) && io.value > threshold;
  },
  
  /** Animation active when analog I/O is in range */
  analogInRange: (min: number, max: number) => (io: IOComponent): boolean => {
    return isAnalogIO(io) && io.value >= min && io.value <= max;
  },
  
  /** Always active */
  always: (): boolean => true,
  
  /** Never active */
  never: (): boolean => false,
};

/**
 * Common value calculators
 */
export const VALUE_CALCULATORS = {
  /** Use analog value directly */
  analogValue: (io: IOComponent): number => {
    return isAnalogIO(io) ? io.value : 0;
  },
  
  /** Use analog percentage (0-100) */
  analogPercentage: (io: IOComponent): number => {
    return isAnalogIO(io) ? io.getPercentage() : 0;
  },
  
  /** Map analog value to range */
  mapRange: (
    inMin: number, 
    inMax: number, 
    outMin: number, 
    outMax: number
  ) => (io: IOComponent): number => {
    if (!isAnalogIO(io)) return 0;
    const value = io.value;
    return ((value - inMin) / (inMax - inMin)) * (outMax - outMin) + outMin;
  },
  
  /** Digital to number (1 or 0) */
  digitalToNumber: (io: IOComponent): number => {
    return isDigitalIO(io) ? (io.value ? 1 : 0) : 0;
  },
};
